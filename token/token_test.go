package token

import (
	"reflect"
	"testing"

	"github.com/stretchr/testify/assert"
)

func Scan(exp string) []*Token {
	var tokens = []*Token{}
	var ch = make(chan *Token, 100)
	if err := Scanner.ParseString(exp, ch); err != nil {
		return nil
	} else {
		for c := range ch {
			tokens = append(tokens, c)
		}
		return tokens
	}
}

func StringAddr(res string) *string {
	return &res
}

func TestLexer(t *testing.T) {
	var err error
	if err != nil {
		panic(err)
	}

	type testCase struct {
		name  string
		input string
		want  []*Token
		typeS []TokenType
		wantS []string
	}

	var testCases = []testCase{
		{
			name:  "TestScan01",
			input: `\ \ \:7:>8908 8+9 x:>=90`,
			want: []*Token{
				{ESCAPE: StringAddr(`\ \ \:`)},
				{NUMBER: StringAddr(`7`)},
				{COLON: StringAddr(":")},
				{COMPARE: StringAddr(">")},
				{NUMBER: StringAddr("8908")},
				{WHITESPACE: StringAddr(" ")},
				{NUMBER: StringAddr("8")},
				{PLUS: StringAddr("+")},
				{NUMBER: StringAddr("9")},
				{WHITESPACE: StringAddr(" ")},
				{IDENT: StringAddr("x")},
				{COLON: StringAddr(":")},
				{COMPARE: StringAddr(">=")},
				{NUMBER: StringAddr("90")},
			},
			typeS: []TokenType{
				ESCAPE_TOKEN_TYPE,
				NUMBER_TOKEN_TYPE,
				COLON_TOKEN_TYPE,
				COMPARE_TOKEN_TYPE,
				NUMBER_TOKEN_TYPE,
				WHITESPACE_TOKEN_TYPE,
				NUMBER_TOKEN_TYPE,
				PLUS_TOKEN_TYPE,
				NUMBER_TOKEN_TYPE,
				WHITESPACE_TOKEN_TYPE,
				IDENT_TOKEN_TYPE,
				COLON_TOKEN_TYPE,
				COMPARE_TOKEN_TYPE,
				NUMBER_TOKEN_TYPE,
			},
			wantS: []string{
				`\ \ \:`,
				`7`,
				":",
				">",
				"8908",
				" ",
				"8",
				"+",
				"9",
				" ",
				"x",
				":",
				">=",
				"90",
			},
		},
		{
			name:  "TestScan02",
			input: `now-8d x:/[\d\s]+/ y:"dasda 8\ : +"`,
			want: []*Token{
				{IDENT: StringAddr("now")},
				{MINUS: StringAddr("-")},
				{NUMBER: StringAddr("8")},
				{IDENT: StringAddr("d")},
				{WHITESPACE: StringAddr(" ")},
				{IDENT: StringAddr("x")},
				{COLON: StringAddr(":")},
				{SLASH: StringAddr("/")},
				{LBRACK: StringAddr("[")},
				{REVERSE: StringAddr("\\")},
				{IDENT: StringAddr("d")},
				{REVERSE: StringAddr("\\")},
				{IDENT: StringAddr("s")},
				{RBRACK: StringAddr("]")},
				{PLUS: StringAddr("+")},
				{SLASH: StringAddr("/")},
				{WHITESPACE: StringAddr(" ")},
				{IDENT: StringAddr("y")},
				{COLON: StringAddr(":")},
				{QUOTE: StringAddr("\"")},
				{IDENT: StringAddr("dasda")},
				{WHITESPACE: StringAddr(" ")},
				{NUMBER: StringAddr("8")},
				{ESCAPE: StringAddr("\\ ")},
				{COLON: StringAddr(":")},
				{WHITESPACE: StringAddr(" ")},
				{PLUS: StringAddr("+")},
				{QUOTE: StringAddr("\"")},
			},
			typeS: []TokenType{
				IDENT_TOKEN_TYPE,
				MINUS_TOKEN_TYPE,
				NUMBER_TOKEN_TYPE,
				IDENT_TOKEN_TYPE,
				WHITESPACE_TOKEN_TYPE,
				IDENT_TOKEN_TYPE,
				COLON_TOKEN_TYPE,
				SLASH_TOKEN_TYPE,
				LBRACK_TOKEN_TYPE,
				REVERSE_TOKEN_TYPE,
				IDENT_TOKEN_TYPE,
				REVERSE_TOKEN_TYPE,
				IDENT_TOKEN_TYPE,
				RBRACK_TOKEN_TYPE,
				PLUS_TOKEN_TYPE,
				SLASH_TOKEN_TYPE,
				WHITESPACE_TOKEN_TYPE,
				IDENT_TOKEN_TYPE,
				COLON_TOKEN_TYPE,
				QUOTE_TOKEN_TYPE,
				IDENT_TOKEN_TYPE,
				WHITESPACE_TOKEN_TYPE,
				NUMBER_TOKEN_TYPE,
				ESCAPE_TOKEN_TYPE,
				COLON_TOKEN_TYPE,
				WHITESPACE_TOKEN_TYPE,
				PLUS_TOKEN_TYPE,
				QUOTE_TOKEN_TYPE,
			},
			wantS: []string{
				"now",
				"-",
				"8",
				"d",
				" ",
				"x",
				":",
				"/",
				"[",
				"\\",
				"d",
				"\\",
				"s",
				"]",
				"+",
				"/",
				" ",
				"y",
				":",
				"\"",
				"dasda",
				" ",
				"8",
				"\\ ",
				":",
				" ",
				"+",
				"\"",
			},
		},
		{
			name:  "TestScan03",
			input: `\!\:.\ \\:<=<(you OR !& \!\&*\** [{ you\[\]+ you?}])^090~9~ouo |!!&&`,
			want: []*Token{
				{ESCAPE: StringAddr(`\!\:`)},
				{DOT: StringAddr(`.`)},
				{ESCAPE: StringAddr(`\ \\`)},
				{COLON: StringAddr(":")},
				{COMPARE: StringAddr("<=")},
				{COMPARE: StringAddr("<")},
				{LPAREN: StringAddr("(")},
				{IDENT: StringAddr("you")},
				{WHITESPACE: StringAddr(" ")},
				{IDENT: StringAddr("OR")},
				{WHITESPACE: StringAddr(" ")},
				{NOT: StringAddr("!")},
				{AND: StringAddr("&")},
				{WHITESPACE: StringAddr(" ")},
				{ESCAPE: StringAddr(`\!\&`)},
				{WILDCARD: StringAddr("*")},
				{ESCAPE: StringAddr(`\*`)},
				{WILDCARD: StringAddr("*")},
				{WHITESPACE: StringAddr(" ")},
				{LBRACK: StringAddr("[")},
				{LBRACE: StringAddr("{")},
				{WHITESPACE: StringAddr(" ")},
				{IDENT: StringAddr(`you`)},
				{ESCAPE: StringAddr(`\[\]`)},
				{PLUS: StringAddr(`+`)},
				{WHITESPACE: StringAddr(" ")},
				{IDENT: StringAddr("you")},
				{WILDCARD: StringAddr("?")},
				{RBRACE: StringAddr("}")},
				{RBRACK: StringAddr("]")},
				{RPAREN: StringAddr(")")},
				{BOOST: StringAddr(`^`)},
				{NUMBER: StringAddr(`090`)},
				{FUZZY: StringAddr(`~`)},
				{NUMBER: StringAddr(`9`)},
				{FUZZY: StringAddr(`~`)},
				{IDENT: StringAddr("ouo")},
				{WHITESPACE: StringAddr(" ")},
				{SOR: StringAddr("|")},
				{NOT: StringAddr("!")},
				{NOT: StringAddr("!")},
				{AND: StringAddr("&")},
				{AND: StringAddr("&")},
			},
			typeS: []TokenType{
				ESCAPE_TOKEN_TYPE,
				DOT_TOKEN_TYPE,
				ESCAPE_TOKEN_TYPE,
				COLON_TOKEN_TYPE,
				COMPARE_TOKEN_TYPE,
				COMPARE_TOKEN_TYPE,
				LPAREN_TOKEN_TYPE,
				IDENT_TOKEN_TYPE,
				WHITESPACE_TOKEN_TYPE,
				IDENT_TOKEN_TYPE,
				WHITESPACE_TOKEN_TYPE,
				NOT_TOKEN_TYPE,
				AND_TOKEN_TYPE,
				WHITESPACE_TOKEN_TYPE,
				ESCAPE_TOKEN_TYPE,
				WILDCARD_TOKEN_TYPE,
				ESCAPE_TOKEN_TYPE,
				WILDCARD_TOKEN_TYPE,
				WHITESPACE_TOKEN_TYPE,
				LBRACK_TOKEN_TYPE,
				LBRACE_TOKEN_TYPE,
				WHITESPACE_TOKEN_TYPE,
				IDENT_TOKEN_TYPE,
				ESCAPE_TOKEN_TYPE,
				PLUS_TOKEN_TYPE,
				WHITESPACE_TOKEN_TYPE,
				IDENT_TOKEN_TYPE,
				WILDCARD_TOKEN_TYPE,
				RBRACE_TOKEN_TYPE,
				RBRACK_TOKEN_TYPE,
				RPAREN_TOKEN_TYPE,
				BOOST_TOKEN_TYPE,
				NUMBER_TOKEN_TYPE,
				FUZZY_TOKEN_TYPE,
				NUMBER_TOKEN_TYPE,
				FUZZY_TOKEN_TYPE,
				IDENT_TOKEN_TYPE,
				WHITESPACE_TOKEN_TYPE,
				SOR_TOKEN_TYPE,
				NOT_TOKEN_TYPE,
				NOT_TOKEN_TYPE,
				AND_TOKEN_TYPE,
				AND_TOKEN_TYPE,
			},
			wantS: []string{
				`\!\:`,
				`.`,
				`\ \\`,
				":",
				"<=",
				"<",
				"(",
				"you",
				" ",
				"OR",
				" ",
				"!",
				"&",
				" ",
				`\!\&`,
				"*",
				`\*`,
				"*",
				" ",
				"[",
				"{",
				" ",
				`you`,
				`\[\]`,
				`+`,
				" ",
				"you",
				"?",
				"}",
				"]",
				")",
				`^`,
				`090`,
				`~`,
				`9`,
				`~`,
				"ouo",
				" ",
				"|",
				"!",
				"!",
				"&",
				"&",
			},
		},
		{
			name:  "TestScan04",
			input: `x:2021-09/d y:/89\/\d+\d*/`,
			want: []*Token{
				{IDENT: StringAddr(`x`)},
				{COLON: StringAddr(":")},
				{NUMBER: StringAddr("2021")},
				{MINUS: StringAddr("-")},
				{NUMBER: StringAddr("09")},
				{SLASH: StringAddr("/")},
				{IDENT: StringAddr("d")},
				{WHITESPACE: StringAddr(" ")},
				{IDENT: StringAddr("y")},
				{COLON: StringAddr(":")},
				{SLASH: StringAddr("/")},
				{NUMBER: StringAddr("89")},
				{ESCAPE: StringAddr("\\/")},
				{REVERSE: StringAddr(`\`)},
				{IDENT: StringAddr("d")},
				{PLUS: StringAddr(`+`)},
				{REVERSE: StringAddr("\\")},
				{IDENT: StringAddr("d")},
				{WILDCARD: StringAddr("*")},
				{SLASH: StringAddr("/")},
			},
			typeS: []TokenType{
				IDENT_TOKEN_TYPE,
				COLON_TOKEN_TYPE,
				NUMBER_TOKEN_TYPE,
				MINUS_TOKEN_TYPE,
				NUMBER_TOKEN_TYPE,
				SLASH_TOKEN_TYPE,
				IDENT_TOKEN_TYPE,
				WHITESPACE_TOKEN_TYPE,
				IDENT_TOKEN_TYPE,
				COLON_TOKEN_TYPE,
				SLASH_TOKEN_TYPE,
				NUMBER_TOKEN_TYPE,
				ESCAPE_TOKEN_TYPE,
				REVERSE_TOKEN_TYPE,
				IDENT_TOKEN_TYPE,
				PLUS_TOKEN_TYPE,
				REVERSE_TOKEN_TYPE,
				IDENT_TOKEN_TYPE,
				WILDCARD_TOKEN_TYPE,
				SLASH_TOKEN_TYPE,
			},
			wantS: []string{
				`x`,
				":",
				"2021",
				"-",
				"09",
				"/",
				"d",
				" ",
				"y",
				":",
				"/",
				"89",
				"\\/",
				`\`,
				"d",
				`+`,
				"\\",
				"d",
				"*",
				"/",
			},
		},
	}
	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			if out := Scan(tt.input); !reflect.DeepEqual(out, tt.want) {
				t.Errorf("Scan ( %+v ) = %+v, but want: %+v", tt.input, out, tt.want)
			} else {
				for i := 0; i < len(out); i++ {
					assert.Equal(t, tt.wantS[i], out[i].String())
				}
				for i := 0; i < len(out); i++ {
					assert.Equal(t, tt.typeS[i], GetTokenType(out[i].String()))
				}
			}
		})
	}

	var x *Token
	assert.Equal(t, "", x.String())
	assert.Equal(t, UNKNOWN_TOKEN_TYPE, GetTokenType(x.String()))
	x = &Token{}
	assert.Equal(t, "", x.String())
	assert.Equal(t, UNKNOWN_TOKEN_TYPE, GetTokenType(x.String()))
	x = &Token{EOL: StringAddr("\n")}
	assert.Equal(t, "\n", x.String())
	assert.Equal(t, EOL_TOKEN_TYPE, GetTokenType(x.String()))
}
